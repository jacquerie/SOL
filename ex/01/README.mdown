# Esercitazione 1 #

Si richiama il C sequenziale: in particolare puntatori, strutture ricorsive,
puntatori a funzione. Poi si introduce con un esempio il concetto di libreria
(che verrà approfondito nelle lezioni di teoria) e si fa la conoscenza con il
debugger.

## Esercizio 1: sul debugging ##

[[Esempio usato per illustrare il debugger DDD]](http://didawiki.cli.di.unipi.it/lib/exe/fetch.php/informatica/sol/laboratorio12/esercitazioni/esempio-ddd.tar)

Usare il debugger [ddd](http://www.gnu.org/software/ddd/manual) per trovare che
cosa non va nel seguente programma C:

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>

#define N 5

int main(void)
{
	int a[N];
	int i;
	srand(time(NULL));

	i=0;
	while (i < N) {
		a[++i] = rand() % 2;
		printf("iterazione %d\n",i);
	}

	printf("exiting ...\n"); 
}
```

In pratica il codice, salvato in `"file.c"`, compilato con

    gcc -Wall -pedantic -o ese file.c

ed eseguito con

    $ ./ese

non è formalmente corretto. Per eseguire in modalità interattiva di debugging:

* Compilare con opzione `"-g"`, ad esempio

    gcc -Wall -pedantic -g -o ese file.c

* Lanciare l'eseguibile usando il debugger come in

    $ ddd ./ese

a questo punto è possibile fermare il programma durante la sua esecuzione,
ispezionare le variabili, ecc...

_Elaborazione:_ Per i solutori più che abili, provare a trovare cosa non va nei
due programmi C in
[esempi.tar](http://didawiki.cli.di.unipi.it/lib/exe/fetch.php/informatica/sol/laboratorio11/esercitazioni/esempi-debug.tar).

## Esercizio 2: liste concatenate di interi ##

Implementare in C le seguenti funzioni che lavorano su liste concatenate di
interi di tipo:

```c
typedef struct nodo {
	int valore;
	struct nodo *next;
} nodo;

typedef nodo *lista;
```

e definire le seguenti funzioni che operano sulla lista:

```c
/** crea una lista vuota
 *  \retval NULL il puntatore alla lista vuota
 */
lista newList (void);

/** dealloca la lista
 *  \param l la lista
 */
void freeList (lista l);
```

Testare il funzionamento delle funzioni implementate con un opportuno `main()`.

## Esercizio 3: map e reduce su liste ##

Usare le liste dell'esercizio 1 implementare le seguenti funzioni:

```c
/** trasforma una lista applicando a ogni elemento la funzione f
 *  \param l la lista
 *  \param f la funzione da mappare
 */
void mapList (int (*f) (int), lista l);

/** combina gli elementi della lista l usando un operatore binario associativo
 *  \param l la lista
 *  \param f l'operatore binario
 *  \param e l'elemento neutro di f
 *
 *  \return la 'somma' degli elementi di l secondo f (l1, f(l2, f(... f (ln, e))))
 */
int reduceList (int (*f) (int, int), int e, lista l);
```

Testare il risultato con un opportuno `main()`.

## Esercizio 4: libreria di liste ##

Realizzare una libreria che fornisce le operazioni su liste implementate negli
esercizi 2 e 3. In C tipicamente per realizzare una libreria si definire un
file `.h` con i prototipi e i tipi messi a disposizione dalla libreria e si
fornisce il codice pre-compilato in un opportuno file di libreria `.a`.

Nel nostro caso l'header si chiamerà `lista.h` e la libreria si chiamerà
`libList.a`. **Nota:** un nome di libreria inizia sempre con `lib`. Il
suffisso `.a` denota una libreria statica.

Procedere nel modo seguente:

* Definire un file `lista.h` che contiene i tipi e i prototipi delle funzioni implementate

* Definire un file `lista.c` che contiene il codice che implementa le funzioni

* Generare il modulo oggetto `lista.o` da inserire nella libreria con il comando `gcc` come segure (si utilizza l'opzione `-c` per passare dal file sorgente `.c` al file oggetto `.o`)

    $ gcc -Wall -pedantic -c lista.c

* Creare la libreria con il comando `ar` come segue (lo scopo di `ar` è impacchettare tutti i file `.o` passati come argomento e impacchettarli in un'unica libreria `.a`)

    $ ar -r libList.a lista.o

L'opzione `-r` sta per _replace_ (se il file non esiste nella libreria, viene
aggiunto; altrimenti rimpiazza precedenti versioni già esistenti). Con il
comando

    $ ar -t libList.a

è possibile elencare i file da cui è composta la nostra libreria (in questo
caso uno solo).
