# Esercitazione 8 #

Questa esercitazione tratta le system call che operano su file.

Per gli esercizi 1, 2, 3, 4 *deve* essere prodotto un opportuno `Makefile` con
target per la creazione di oggetti ed eseguibili e per l'esecuzione del test
automatico del codice prodotto.

L'accesso ai file e alle directory deve essere effettuato *esclusivamente*
utilizzando le system call viste a lezione. La soluzione *deve* includere la
gestione degli errori con una delle tecniche discusse.

## Esercizio 1: `mycat` ##

Scrivere un programma C che implementa l'utility `mycat` con il seguente comportamento:
```
$ mycat file
```

prova ad aprire `file` e, se ci riesce, stampa il suo contenuto sullo `stdout`.
Se attivata in modo errato `mycat` stampa un breve messaggio di errore, ad
esempio
```
$ mycat file1 file2
Uso: mycat file 
     Stampa il contenuto di un singolo file su stdout
```

Utilizzare il comando `strace` (`man strace`) per eseguire `mycat` in modo da
visualizzare e intercettare tutte le system call invocate.

### Approfondimento: ###

Sostituire le chiamate di sistema con le chiamate di libreria `stdio` (`fopen`,
`fread`, `fwrite`, ...) e verificare cosa cambia con `strace`.

## Esercizio 2: `mycat` (2) ##

Estendere `mycat` (Esercizio 1) in modo da accettare una lista di file
```
$ mycat file1 ... fileN
```

per ogni file che riesce ad aprire, `mycat` stampa il contenuto su `stdout`
preceduto da una breve intestazione, ad esempio
```
**************************
*       fileK            *
**************************
```

Per ogni file che non riesce ad aprire, `mycat` stampa un messaggio d'errore su
`stderr`.

Inoltre si implementi l'opzione `[-o fileout]` che permette di specificare un
file (`fileout`) di output diverso dallo `stdout`.

_Nota:_ l'opzione `-o` può essere specificata in una posizione arbitraria della
lista degli argomenti, per il parsing della linea di comando è possibile
utilizzare la funzione di libreria `getopt()` (vedi `man 3 getpot`).

## Esercizio 3: `mystat` ##

Realizzare il comando `mystat`
```
$ mystat file1 ... fileN
```

che stampa vari attributi nell'i-node dei file con path `file1 ... fineN`. In
particolare devono essere stampati almeno il numero di i-node, il tipo del file
(regolare, directory, eccetera...), la maschera di protezione (ad esempio
`rw-r--r--`), l'user identifier (`uid`), il group identifier (`gid`) e il tempo
dell'ultima modifica.

_Suggerimento:_ fare qualche esperimento con il comando `stat` (`man 1 stat`),
usare la system call `stat()`, convertire il tempo d'accesso in una stringa
stampabile con la funzione di libreria `ctime()` in `time.h`, usare
`getpwuid()` e `getgrgid()` per convertire `uid` e `gid` nei nomi
corrispondenti.

## Esercizio 4: `myfnd` ##

Realizzare il comando `myfnd`

```
myfnd dir namef
```

che cerca ricorsivamente il file `namef` nel sottoalbero radicato nella
directory `dir`.  Per ogni file `namef` trovato stampa il path assoluto della
directory in cui è stato trovato e la data dell'ultima modifica. Ad esempio

```
$ myfnd . gigi
/home/susanna/bin/gigi  2007-03-16 14:00
/home/susanna/bin/xxx/gigi  2006-07-10 13:10
```
